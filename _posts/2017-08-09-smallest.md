---
published: true
layout: post
title: The Smallest Free Number
date: 2017-08-09
excerpt: Pearls of Functional Algorithm Design - The Smallest Free Number
categories:
  - Algorithms
  - Functional Programming
  - OCaml
tags:
  - functional programming
  - algorithm design
  - pearls of functional algorithm design
comments: true
---

In this post, I would like to start a topic about functional algorithm design. I will use OCaml language to implement the designs.
Each post is about a "functional pearl" from the book ["Pearls of Functional Algorithm Desgin"][1] by Richard Bird. 

## Introduction

Given a set `X` of `n` natural numbers, we want to find the smallest natural number such that it is not in `X`. In practice, this problem can
be considered as the following common programming task. There is a number of object ids and `X` is the set of objects currently in use. The task
is to find some object not in use, say the one with the smallest id.

## Non-linear Solution

We assume that `X` is a list without duplicates in no particular order. Otherwise, let's say `X` is in increasing order, then the **linear** solution is trivial: **simply
look for the first gap and check the first element is different from `0`**. For example,

`X` = [1; 2; 3; 6; 9], then we first check `1` is different from `0`, thus `0` is the smallest number we are looking for.
Consider an other example, `X` = [0; 1; 2; 3; 6; 9], then we check the gap between two continuous elements from the begining of the list. In this case,
`6 - 3 > 1`, thus `3+1` is the number we are looking for.

The implementation is given as follows.
```ocaml
(* l is in increasing order *)
let trivial_smallest l =
  let rec aux l res =
  match l with
  | [] -> res
  | x::[] -> aux [] (x + 1)
  | x1::x2::xs -> if x2 - x1 > 1 then (x1 + 1) else aux x2::xs res
  in 
  if (List.length l = 0 ) || (List.hd l <> 0) then 0
  else aux l 0;; 
```

## An Array-based Solution

## Source code

[1]: https://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383


---
published: true
layout: post
title: The Smallest Free Number
date: 2017-08-09
excerpt: Pearls of Functional Algorithm Design - The Smallest Free Number
categories:
  - Algorithms
  - Functional Programming
  - OCaml
tags:
  - functional programming
  - algorithm design
  - pearls of functional algorithm design
comments: true
---

In this post, I would like to start a topic about functional algorithm design. I will use OCaml language to implement the designs.
Each post is about a "functional pearl" from the book ["Pearls of Functional Algorithm Desgin"][1] by Richard Bird. 

## Introduction

Given a set `X` of `n` natural numbers, we want to find the smallest natural number such that it is not in `X`. In practice, this problem can
be considered as the following common programming task. There is a number of object ids and `X` is the set of objects currently in use. The task
is to find some object not in use, say the one with the smallest id.

Our objective is to design an algorithm whose asymtotic complexity is **linear**, $$O(n)$$ where `n` is the number of elements in `X`.

## Non-linear Solution

We assume that `X` is a list without duplicates in no particular order. Otherwise, let's say `X` is in increasing order, then the **linear** solution is trivial: **simply
look for the first gap and check the first element is different from `0`**. For example,

`X` = [1; 2; 3; 6; 9], then we first check `1` is different from `0`, thus `0` is the smallest number we are looking for.
Consider an other example, `X` = [0; 1; 2; 3; 6; 9], then we check the gap between two continuous elements from the begining of the list. In this case,
`6 - 3 > 1`, thus `3+1` is the number we are looking for.

The implementation is given as follows.
```ocaml
(* l is in increasing order *)
let trivial_smallest l =
  let rec aux l res =
  match l with
  | [] -> res
  | x::[] -> aux [] (x + 1)
  | x1::x2::xs -> if x2 - x1 > 1 then (x1 + 1) else aux (x2::xs) res
  in 
  if (List.length l = 0 ) || (List.hd l <> 0) then 0
  else aux l 0;; 
```

Consider the following quadratic algorithm where `filter : int list -> int list -> int list` takes the list `[0;1;...;n]` and input list `X` and
returns the list of elements in the first input list in which any occurence of `x` in `X` is removed. Then, the number we are looing for is the head of
the returned list. The implementation is given below.
```ocaml
(* use the List's mem and filter functions *)
let quadratic_smallest l =
  let n = List.length l in
  let rec loop i l =
    if i = 0 then (i::l)
    else
      loop (pred i) (i::l)
  in
  let pre_l = loop n [] in
  let filter l1 l2 =
    List.filter (fun x -> not (List.mem x l2)) l1
  in
  List.hd (filter pre_l l)
```

```ocaml
(* test function *)
let remove_duplicate l =
  let rec aux l res =
    match l with
    | [] -> List.rev res
    | x::xs -> let filtered = List.filter (fun y -> not (x = y)) xs in
      aux filtered (x::res)
  in
  aux l [];;
  
let create_input n =  
  let rec loop i l =
    if i = 0 then (i::l)
    else
      loop (pred i) (c::l)
  in
  loop n [];;

let test f n =
  let t = Sys.time() in
  let s = f (create_input n) in
  Printf.printf "Execution time: %fs\n" (Sys.time() -. t);
  s
```

The funtion `quadratic_smallest` works, however whose asymtotic complexity is quadratic $$O(n^2)$$ because `List.mem` and `List.filter` are $$O(n)$$ where `n`
is the length of the input list `X`.

One can think about the other solution is that we first sort the input list `X`, then employ the above **linear** trivial algorithm. However, the complexity
of the sort algorithm is at least $$O(nlogn)$$. Hence, this solution is $$O(nlogn)$$. In the following, I will discuss two **linear** algorithms based on array data structe and divide and conquer.

## An Array-based Solution

## Devide and Conquer


[1]: https://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383

